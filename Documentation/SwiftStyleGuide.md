# Swift Style Guide

This document describes the Swift coding style used on the Swift Package Manager project. It provides a set of rules for all contributors to follow and promotes a consistence that helps when reading code written by different people. This is a living document that should be updated as the style evolves and solidifies.

When necessary, break the rules to improve readability.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [General](#general)
    - [Follow the official API Design Guidelines](#follow-the-official-api-design-guidelines)
    - [Fix all warnings](#fix-all-warnings)
    - [Prefix source files with the copyright header](#prefix-source-files-with-the-copyright-header)
- [Naming](#naming)
- [Formatting](#formatting)
  - [General](#general-1)
    - [Omit semicolons](#omit-semicolons)
    - [Avoid long lines of code and limit them to 120 characters](#avoid-long-lines-of-code-and-limit-them-to-120-characters)
    - [When wrapping function calls and declaration, indent each argument on a line of its own](#when-wrapping-function-calls-and-declaration-indent-each-argument-on-a-line-of-its-own)
    - [When wrapping function declarations, place the closing parentheses on a line of its own](#when-wrapping-function-declarations-place-the-closing-parentheses-on-a-line-of-its-own)
    - [Open braces on the same line but close on a newline](#open-braces-on-the-same-line-but-close-on-a-newline)
    - [When wrapping statement conditions, open braces on a newline](#when-wrapping-statement-conditions-open-braces-on-a-newline)
    - [Only use the trailing closure syntax for procedural arguments](#only-use-the-trailing-closure-syntax-for-procedural-arguments)
    - [Format multiline collections with trailing commas and dangling brackets](#format-multiline-collections-with-trailing-commas-and-dangling-brackets)
  - [Whitespace](#whitespace)
    - [Indent code using 4 spaces](#indent-code-using-4-spaces)
    - [Remove all trailing whitespace (even on empty lines)](#remove-all-trailing-whitespace-even-on-empty-lines)
    - [Follow conventional spacing for lists](#follow-conventional-spacing-for-lists)
    - [Hug colons to the left and follow with a space](#hug-colons-to-the-left-and-follow-with-a-space)
    - [Insert internal spaces inside closures](#insert-internal-spaces-inside-closures)
    - [Separate functions and top-level scopes with one empty line](#separate-functions-and-top-level-scopes-with-one-empty-line)
    - [When chaining function calls, indent each call on its own line](#when-chaining-function-calls-indent-each-call-on-its-own-line)
- [Code Organization](#code-organization)
  - [Extensions](#extensions)
    - [Use extensions to organize code into logical blocks of functionality](#use-extensions-to-organize-code-into-logical-blocks-of-functionality)
    - [Use extensions to group protocol conformances](#use-extensions-to-group-protocol-conformances)
    - [Use extensions to group members with the same visibility](#use-extensions-to-group-members-with-the-same-visibility)
- [Comments](#comments)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## General

#### Follow the official API Design Guidelines

The official [API Design Guidelines](https://swift.org/documentation/api-design-guidelines) are a short and high-level summary of the most important naming and code conventions used among Swift developers. It is important to follow them so that code in the Swift Package Manager feels consistent with the Standard Library and other third-party libraries. The fundamentals are resumed as:

* Clarity at the point of use is your most important goal.
* Clarity is more important than brevity.
* Write a documentation comment for every declaration.

#### Fix all warnings

The warnings generated by the Swift compiler exist for a reason. Fixing them often results in better code and makes sure that new warnings are spotted immediately.

#### Prefix source files with the copyright header

```swift
/*
 This source file is part of the Swift.org open source project
 Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
 Licensed under Apache License v2.0 with Runtime Library Exception
 See http://swift.org/LICENSE.txt for license information
 See http://swift.org/CONTRIBUTORS.txt for Swift project authors
*/
```

## Naming

## Formatting

### General

#### Omit semicolons

Traditional Swift code avoids semicolons. They are unnecessary and hinder readability.

#### Avoid long lines of code and limit them to 120 characters

Long lines of code can be difficult to read. If possible, prefer splitting them into separate statements. If not, hard-wrapping ensures that we stay consistent in the presentation. The limit of 120 characters was chosen to be the most generous length that still fits in GitHub diffs without vertical scrolling.

```swift
let error = WorkspaceDiagnostics.MismatchingDestinationPackage(
    editPath: destination,
    expectedPackage: packageName,
    destinationPackage: manifest?.name)
```

#### When wrapping function calls and declaration, indent each argument on a line of its own

This style helps align arguments when they are many to read.

```swift
parser.add(
    position: "executable",
    kind: String.self,
    optional: true,
    strategy: .remaining,
    usage: "Executable to run")
```

#### When wrapping function declarations, place the closing parentheses on a line of its own

By following this style, the body to stays visually separate from the declaration.

```swift
func add<T: ArgumentKind>(
    positional: String,
    kind: [T].Type,
    optional: Bool = false,
    strategy: ArrayParsingStrategy = .upToNextOption,
    usage: String? = nil
) -> PositionalArgument<[T]> {
    let argument = PositionalArgument<[T]>(name: positional, strategy: strategy, optional: optional, usage: usage)
    positionalArguments.append(AnyArgument(argument))
    return argument
}
```

#### Open braces on the same line but close on a newline

```swift
func add(_ values: [ArgumentKind], for argument: AnyArgument) throws {
    if argument.isArray {
        results[argument, default: []].append(contentsOf: values)
    } else {
        results[argument] = values[0]
    }
}
```

#### When wrapping statement conditions, open braces on a newline

As with the wrapping rules of function declaration, this style helps distinguish the body from the condition.

```swift
if let maxArgument = (positionalArguments + optionArguments).map({ $0.name.characters.count }).max(),
    maxArgument < maxWidthDefault
{
    maxWidth = maxArgument + padding + 1
} else {
    maxWidth = maxWidthDefault
}
```

#### Only use the trailing closure syntax for procedural arguments

This is essentially the Rule of Kevin (Ballard): "When a trailing closure argument is functional, use parentheses. When it is procedural, use braces." Functional closures are recognized as outputting some transformation on their input without generating any side-effect. `map`, `flatMap`, `reduce`, `contains` are all examples of functions which work on functional closures.

```swift
// Procedural, trailing closure
Dispatch.main.async {
    // Functional, no trailing closure
    print(array.flatMap({ Int($0) }))
}
```

#### Format multiline collections with trailing commas and dangling brackets

```swift
let colors: [String: Color] = [
    "white": .white,
    "pink": UIColor(hex: 0xFFAAAA),
    "green": UIColor(hex: 0xAAFFAA),
    "cyan": UIColor(hex: 0xAAAAFF),
]
```

### Whitespace

#### Indent code using 4 spaces

Indenting with 4 spaces is the standard used all over the Swift community.

#### Remove all trailing whitespace (even on empty lines)

Trailing whitespace result in un-necessary noise when reading diffs. Most code editors have a setting to remove them automatically.

<details>
  <summary>Xcode Trailing Whitespace Setting</summary>
  <img src="Assets/TrailingWhitespace.png"/>
</details>

#### Follow conventional spacing for lists

Parentheses and angle and square brackets don't have internal space. For commas, hug to the left and follow with a space:

```swift
min(a, b) // Argument list
[x, y, z] // Array literal
Dictionary<Key, Value> // Generic parameter list
enum Shell: String, StringEnumArgument { ... } // Inheritance list
```

#### Hug colons to the left and follow with a space

One minor exception to this rule is the empty dictionary literal `[:]`:

```swift
struct PathArgument: ArgumentKind { ... }
let mapping: [String: Int] = ["one": 1, "two": 2]
```

#### Insert internal spaces inside closures

Furthermore, non-trailing closures follow the same spacing rules as any other argument and trailing closures are prefixed with a space.

```swift
array
    .map({ $0.lowercased })
    .forEach { print($0) }
```

#### Separate functions and top-level scopes with one empty line

```swift
public class GridPoint {
    public let x: Double
    public let y: Double

    public init(x: Double, y: Double) {
        self.x = x
        self.y = y
    }
}

// MARK: - Public Members
public extension {
    var hashValue: Int {
        return x.hashValue ^ y.hashValue
    }
 
    static func ==(lhs: GridPoint, rhs: GridPoint) -> Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y
    }
}
```

#### When chaining function calls, indent each call on its own line

```swift
return items
    .sorted(by: { (lhs, rhs) in lhs.0 < rhs.0 })
    .map({ key, value in
        let serialized = value.serializer() 
        return "\(key) = \(value) "
    })
    .joined(separator: "; ")
```

## Code Organization

* Remove unused code and stale comments. Source control allows us to keep of trace of everything that was once committed.

```swift

```

* Remove imports which are not required

```swift
import Basic // Should be removed at is indirectly imported through Utility
import Utility
```

### Extensions

#### Use extensions to organize code into logical blocks of functionality

Extensions are a natural way to group together members of a type. Prefix them with `// MARK: - ` followed by a capitalized title not ending with punctuation.

#### Use extensions to group protocol conformances

```swift
// MARK: - Hashable Conformance
extension GridPoint: Hashable {
    var hashValue: Int {
        return x.hashValue ^ y.hashValue
    }
 
    static func == (lhs: GridPoint, rhs: GridPoint) -> Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y
    }
}
```

#### Use extensions to group members with the same visibility

Grouping members with the same visibility and using the extension's visibility propagation feature encourages developers to move members to the correct group when changing their visibility:

```swift
// MARK: - Public Members
public extension GridPoint {
    func distance(to other: GridPoint) -> Double {
        return sqrt(distanceSquared(to: other))
    }
}

// MARK: - Private Members
private extension GridPoint {
    func distanceSquared(to other: GridPoint) -> Double {
        let deltaX = other.x - x
        let deltaY = other.y - y
        return deltaX * deltaX + deltaY * deltaY
    }
}
```

## Comments

* Don't need them for protocol conformances